
@DSL Implicit;
@Behaviour Lubby2;
@Author Thomas Nagel;
@Description{Lubby2 model for stationary
and transient creep based on Burgers
rheological model};

@Algorithm NewtonRaphson;
@MaximumNumberOfIterations 100;

@Brick StandardElasticity;

@Epsilon 1.e-14;
@Theta 1.0;
@Parameter local_zero_tolerance = 1.e-14;

@ModellingHypotheses{".+"};
@RequireStiffnessTensor<UnAltered>;

// Intercept of yield function
@MaterialProperty real GK0;
GK0.setEntryName("KelvinShearModulus");
@MaterialProperty real etaK0;
etaK0.setEntryName("KelvinViscosity");
@MaterialProperty real etaM0;
etaM0.setEntryName("MaxwellViscosity");
@MaterialProperty real mK;
mK.setEntryName("KelvinElasticParameter");
@MaterialProperty real mvK;
mvK.setEntryName("KelvinViscoParameter");
@MaterialProperty real mvM;
mvM.setEntryName("MaxwellViscoParameter");

@StateVariable Stensor epsK;
epsK.setEntryName("KelvinStrain");

@StateVariable Stensor epsM;
epsM.setEntryName("MaxwellStrain");

@Integrator
{
    // Implicit system
    constexpr const auto id4 = Stensor4::Id();
    const auto Pdev = Stensor4::K();

    const auto sigma_eff =
        std::max(sigmaeq(sig), local_zero_tolerance * D(0, 0));

    const auto s = deviator(sig);

    const auto etaK = etaK0 * std::exp(mvK * sigma_eff);
    const auto etaM = etaM0 * std::exp(mvM * sigma_eff);
    const auto GK = GK0 * std::exp(mK * sigma_eff);

    // residuals
    feel += depsM + depsK;

    // calculate Kelvin strain residual
    fepsK = depsK - dt / (2.0 * etaK) * (s - 2.0 * GK * (epsK + depsK));

    // calculate Maxwell strain residual
    fepsM = depsM - dt / (2.0 * etaM) * s;

    // Jacobian
    const auto dsigma_eff_ddeel = 3. / (2. * sigma_eff) * s | (Pdev * D);
    const auto detaK_ddeel = etaK * mvK * dsigma_eff_ddeel;
    const auto detaM_ddeel = etaM * mvM * dsigma_eff_ddeel;
    const auto dGK_ddeel = GK * mK * dsigma_eff_ddeel;

    dfeel_ddeel = id4;
    dfeel_ddepsK = id4;
    dfeel_ddepsM = id4;

    dfepsK_ddeel = (dt / (2.0 * etaK * etaK) * (s - 2.0 * GK * (epsK + depsK)) ^
                    detaK_ddeel) -
                   (dt / (2.0 * etaK) * Pdev * D) +
                   (dt / etaK * (epsK + depsK) ^ dGK_ddeel);
    dfepsK_ddepsK = (1. + dt * GK / etaK) * id4;
    // dfepsK_ddepsM is all zero --> nothing to do

    dfepsM_ddeel = (dt / (2.0 * etaM * etaM) * s ^ detaM_ddeel) -
                   (dt / (2.0 * etaM) * Pdev * D);
    // dfepsM_ddepsK is all zero --> nothing to do
    dfepsM_ddepsM = id4;
}
